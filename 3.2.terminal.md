### Задание 1
<i>Какого типа команда cd? Попробуйте объяснить, почему она именно такого типа: опишите ход своих мыслей, если считаете, что она могла бы быть другого типа.</i>
* type -a cd
cd is a shell builtin
т.е. всстроенная команда

> cd данного типа,т.к. если будет определена функция с таким же именем,
как у встроенной оболочки, то функциональность cd сохранится.
можно сказать, что команда зарезервированна для того,
что бы не нарушить работоспособность системы

* vagrant@ubuntu-focal:~$ builtin cd /home

### Задание 2
<i>Какая альтернатива без pipe команде <code>grep <some_string> <some_file> | wc -l?</code></i>
* grep <some_string> <some_file> -c  
согласно ману -c, --count счётчик
* vagrant@ubuntu-focal:/~$ grep a .profile  | wc -l  
15
* vagrant@ubuntu-focal:/~$ grep a .profile  -c  
15


### Задание 3
<i>Какой процесс с PID 1 является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?</i>
* vagrant@ubuntu-focal:~$ ps 1  
    PID TTY      STAT   TIME COMMAND  
      1 ?        Ss     0:05 /sbin/init  
или
* vagrant@ubuntu-focal:~$ pstree -p  
systemd(1)

> В момент загрузки ядра создаётся особый процесс с PID=1,
который должен существовать до перезагрузки ОС.
В первом процессе исполняется программа init


### Задание 4
<i>Как будет выглядеть команда, которая перенаправит вывод stderr ls на другую сессию терминала?</i>

* vagrant@ubuntu-focal:~$ ls -l ~/ 2>/dev/pts/1


### Задание 5
<i>Получится ли одновременно передать команде файл на stdin и вывести ее stdout в другой файл? Приведите работающий пример.</i>

>vagrant@ubuntu-focal:$ cat test.sh  
[[ -d /tmp ]];echo $?   
vagrant@ubuntu-focal:$ ./test.sh  
0  
vagrant@ubuntu-focal:$ cat test.sh > test2  
vagrant@ubuntu-focal:$ cat test2  
[[ -d /tmp ]];echo $?  
vagrant@ubuntu-focal:$ cat < test.sh > test2  
 * < Назначить ввод из входного файла.
 * \> Назначить вывод в выходной файл.
 *  Предполагается, что выходной файл доступен для записи  
vagrant@ubuntu-focal:$ cat test2  
[[ -d /tmp ]];echo $?  


### Задание 6
<i>Получится ли, находясь в графическом режиме, вывести данные из PTY в какой-либо из эмуляторов TTY? Сможете ли вы наблюдать выводимые данные?</i>
* Вывести данные из PTY получится, но наблюдать в графическом режиме не получится.

### Задание 7
<i>Выполните команду bash 5>&1. К чему она приведет? Что будет, если вы выполните<code> echo netology > /proc/$$/fd/5?</code> Почему так происходит?</i>
* bash 5>&1 создаст новый дескриптор
файла и перенаправит его на 1, который является STDOUT.

* vagrant@ubuntu-focal:~$ echo netology > /proc/$$/fd/5  
netology

* запишет "netology" в созданный ранее дескриптер 5 и выведет его на экран

### Задание 8
<i>Получится ли в качестве входного потока для pipe использовать только stderr команды, не потеряв при этом отображение stdout на pty?</i>
* cat /root/new_file 5>&2 2>&1 1>&5 | grep "Permission denied" -c

* 1 дескриптер направили в STDERR
* 2 STDERR перенаправили в STDOUT
* 3 STDOUT перенаправили в созданный дескриптер
* 4 передаем через pipe на grep и считаем количество совпадений


### Задание 9
<i>Что выведет команда <code> cat /proc/$$/environ?</code> Как еще можно получить аналогичный по содержанию вывод?</i>
* будут выведены переменные окружения
аналогичная команда  
printenv


### Задание 10
<i>Используя man, опишите что доступно по адресам <code>/proc/<PID>/cmdline</code>, <code>/proc/<PID>/exe</code>.</i>

* proc/<PID>/cmdline -  
> Этот доступный только для чтения файл
содержит полную командную строку для процесса,
 если этот процесс не является зомби. (строка 226)
* /proc/<PID>/exe -  
> В Linux 2.2 и более поздних версиях этот файл
представляет собой символическую ссылку,
содержащую фактический путь к исполняемому файлу.(строка 279)

### Задание 11
<i>Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с помощью <code>/proc/cpuinfo.</code></i>


* cat /proc/cpuinfo | grep sse
* sse4_2

### Задание 12
<i>При открытии нового окна терминала и vagrant ssh создается новая сессия и выделяется pty.
Это можно подтвердить командой tty, которая упоминалась в лекции 3.2.</i>


> так происходит потому что по умолчанию,
когда вы запускаете команду на удаленном
компьютере с помощью ssh, TTY не выделяется для удаленного сеанса.

> Если вам нужна оболочка на ПК2, используйте вместо этого ключ -t,
что вызовет выделение TTY во время удаленного выполнения:
* ssh -t user@computerone.com 'ssh otheruser@computertwo.com'

### Задание 13
<i>Бывает, что есть необходимость переместить запущенный процесс из одной сессии в другую. Попробуйте сделать это, воспользовавшись reptyr. Например, так можно перенести в screen процесс, который вы запустили по ошибке в обычной SSH-сессии.</i>  

> например мы запустили копирование и не хотим обрывать
нам необходимо подключиться второй раз по ssh, открыть скрин
* screen -r
> выяснить PID нужного нам процесса, например ps ax | grep cp
выполнить
* reptyr PID
> Дополнение -  
> reptyr зависит от системного вызова ptrace(2) для подключения к удаленной программе. В Ubuntu Maverick и выше эта возможность по умолчанию отключена из соображений безопасности. Вы можете временно включить его, выполнив
<code>echo 0 > /proc/sys/kernel/yama/ptrace_scope</code>

* собственно выполнил <code>echo 0 | sudo tee /proc/sys/kernel/yama/ptrace_scope</code> и всё заработало



### Задание 14
<i>Бывает, что есть необходимость переместить запущенный процесс из одной сессии в другую. Попробуйте сделать это, воспользовавшись reptyr. Например, так можно перенести в screen процесс, который вы запустили по ошибке в обычной SSH-сессии.

<code>sudo echo string > /root/new_file</code> не даст выполнить перенаправление под обычным пользователем, так как перенаправлением занимается процесс shell'а, который запущен без sudo под вашим пользователем. Для решения данной проблемы можно использовать конструкцию<code> echo string | sudo tee /root/new_file</code>. Узнайте? что делает команда tee и почему в отличие от sudo echo команда с sudo tee будет работать.</i>

> tee в Linux считывает стандартный ввод и записывает его одновременно
 в стандартный вывод и в один или несколько подготовленных файлов.

> команда будет работать т.к. мы передаем string  в запущенную
от sudo команду tee, которая имеет права на редактирование файла
! в отличии от первого примера, там мы от sudo запускаем команду
echo(что бессмысленно) т.к. на запуск echo есть права у любого пользователя
и далее записывает в файл процесс shell-a который запущен
от непривелигированного пользователя.

<hr>

