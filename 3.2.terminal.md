### Задание 1
* type -a cd
cd is a shell builtin
т.е. всстроенная команда

> cd данного типа,т.к. если будет определена функция с таким же именем,
как у встроенной оболочки, то функциональность cd сохранится.
можно сказать, что команда зарезервированна для того,
что бы не нарушить работоспособность системы

* vagrant@ubuntu-focal:~$ builtin cd /home

### Задание 2
* grep <some_string> <some_file> -c
согласно ману -c, --count
vagrant@ubuntu-focal:~$ grep a .profile  | wc -l
15
vagrant@ubuntu-focal:~$ grep a .profile  -c
15


### Задание 3
* vagrant@ubuntu-focal:~$ ps 1
    PID TTY      STAT   TIME COMMAND
      1 ?        Ss     0:05 /sbin/init
или
* vagrant@ubuntu-focal:~$ pstree -p
systemd(1)

> В момент загрузки ядра создаётся особый процесс с PID=1,
который должен существовать до перезагрузки ОС.
В первом процессе исполняется программа init


### Задание 4


* vagrant@ubuntu-focal:~$ ls -l ~/ 2>/dev/pts/1


### Задание 5
>vagrant@ubuntu-focal:~$ cat test.sh
[[ -d /tmp ]];echo $?
vagrant@ubuntu-focal:~$ ./test.sh
0
vagrant@ubuntu-focal:~$ cat test.sh > test2
vagrant@ubuntu-focal:~$ cat test2
[[ -d /tmp ]];echo $?
vagrant@ubuntu-focal:~$ cat < test.sh > test2
 * < Назначить ввод из входного файла.
 * \> Назначить вывод в выходной файл.
 *  Предполагается, что выходной файл доступен для записи
vagrant@ubuntu-focal:~$ cat test2
[[ -d /tmp ]];echo $?


### Задание 6
* Вывести данные из PTY получится, но наблюдать в графическом режиме не получится.

### Задание 7

* bash 5>&1 создаст новый дескриптор
файла и перенаправит его на 1, который является STDOUT.

* vagrant@ubuntu-focal:~$ echo netology > /proc/$$/fd/5
netology

* запишет "netology" в созданный ранее дескриптер 5 и выведет его на экран

### Задание 8

* cat /root/new_file 5>&2 2>&1 1>&5 | grep "Permission denied" -c

* 1 дескриптер направили в STDERR
* 2 STDERR перенаправили в STDOUT
* 3 STDOUT перенаправили в созданный дескриптер
* 4 передаем через pipe на grep и считаем количество совпадений


### Задание 9

* будут выведены переменные окружения
аналогичная команда
printenv


### Задание 10
* proc/<PID>/cmdline -
> Этот доступный только для чтения файл
содержит полную командную строку для процесса,
 если этот процесс не является зомби. (строка 226)
* /proc/<PID>/exe -
> В Linux 2.2 и более поздних версиях этот файл
представляет собой символическую ссылку,
содержащую фактический путь к исполняемому файлу.(строка 279)

### Задание 11
* cat /proc/cpuinfo | grep sse
* sse4_2

### Задание 12
> так происходит потому что по умолчанию,
когда вы запускаете команду на удаленном
компьютере с помощью ssh, TTY не выделяется для удаленного сеанса.

> Если вам нужна оболочка на ПК2, используйте вместо этого ключ -t,
что вызовет выделение TTY во время удаленного выполнения:
* ssh -t user@computerone.com 'ssh otheruser@computertwo.com'

### Задание 13
> например мы запустили копирование и не хотим обрывать
нам необходимо подключиться второй раз по ssh, открыть скрин
* screen -r
> выяснить PID нужного нам процесса, например ps ax | grep cp
выполнить
* reptyr PID

### Задание 14

> tee в Linux считывает стандартный ввод и записывает его одновременно
 в стандартный вывод и в один или несколько подготовленных файлов.

> команда будет работать т.к. мы передаем string  в запущенную
от sudo команду tee, которая имеет права на редактирование файла
! в отличии от первого примера, там мы от sudo запускаем команду
echo(что бессмысленно) т.к. на запуск echo есть права у любого пользователя
и далее записывает в файл процесс shell-a который запущен
от непривелигированного пользователя.

<hr>

